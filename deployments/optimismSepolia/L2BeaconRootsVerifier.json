{
  "address": "0xe094C96145fe094D3Cb6bF05d8cFD08E92f11BE5",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_l2BeaconRoots",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "L2_BEACON_ROOTS",
      "outputs": [
        {
          "internalType": "contract L2BeaconRoots",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_timestamp",
          "type": "uint256"
        },
        {
          "internalType": "bytes32[]",
          "name": "_proofs",
          "type": "bytes32[]"
        },
        {
          "internalType": "bytes32",
          "name": "_withdrawalsRoot",
          "type": "bytes32"
        }
      ],
      "name": "verify",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x1e3ddaad2d1c557bfa7ec1ea8372bd974150d008e242689f7bcbac852f77b420",
  "receipt": {
    "to": null,
    "from": "0xFD94B77dEf93B655b37F149d58cb3AD21743180F",
    "contractAddress": "0xe094C96145fe094D3Cb6bF05d8cFD08E92f11BE5",
    "transactionIndex": 3,
    "gasUsed": "284738",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x2890ff10496efc261a5d2949617006d2aa82794acc950441f5feb06cf06342d9",
    "transactionHash": "0x1e3ddaad2d1c557bfa7ec1ea8372bd974150d008e242689f7bcbac852f77b420",
    "logs": [],
    "blockNumber": 17694281,
    "cumulativeGasUsed": "2070229",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xb53F763AB795e2A2C13613e25cc54939Ca01b4E1"
  ],
  "numDeployments": 1,
  "solcInputHash": "a157e738c91afa8cf3cbba2db2aa1381",
  "metadata": "{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_l2BeaconRoots\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"L2_BEACON_ROOTS\",\"outputs\":[{\"internalType\":\"contract L2BeaconRoots\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_proofs\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32\",\"name\":\"_withdrawalsRoot\",\"type\":\"bytes32\"}],\"name\":\"verify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"constructor\":{\"params\":{\"_l2BeaconRoots\":\": The address of the L2BeaconRoots contract\"}},\"verify(uint256,bytes32[],bytes32)\":{\"params\":{\"_proofs\":\": The Merkle proof\",\"_timestamp\":\": The timestamp of the Beacon Block\",\"_withdrawalsRoot\":\": The Withdrawals Root to verify\"}}},\"title\":\"L2BeaconRootsVerifier\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"verify(uint256,bytes32[],bytes32)\":{\"notice\":\"Verifies a Withdrawals Root Merkle proof for a given timestamp\"}},\"notice\":\"The L2BeaconRootsVerifier contract responsible for verifyring Beacon Block SSZ Merkle proofs\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/src/L2BeaconRootsVerifier.sol\":\"L2BeaconRootsVerifier\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":100},\"remappings\":[],\"viaIR\":true},\"sources\":{\"contracts/src/L1BeaconRootsSender.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport \\\"./L2BeaconRoots.sol\\\";\\n\\n/// @title IL1CrossDomainMessenger\\n/// @notice Interface for the OP L1CrossDomainMessenger contract\\ninterface IL1CrossDomainMessenger {\\n    function sendMessage(address _target, bytes calldata _message, uint32 _gasLimit) external;\\n}\\n\\n/// @title L1BeaconRootsSender\\n/// @notice The L1BeaconRootsSender contract sends the beacon chain block roots to the L2BeaconRoots contract on the L2\\ncontract L1BeaconRootsSender {\\n    /// @notice The OP L1CrossDomainMessenger contract\\n    IL1CrossDomainMessenger public immutable L1_MESSENGER;\\n\\n    /// @notice The L2BeaconRoots contract on the L2\\n    L2BeaconRoots public immutable L2_BEACON_ROOTS;\\n\\n    /// @notice The required gas limit for executing the set function on the L2BeaconRoots contract\\n    uint32 public constant L2_BEACON_ROOTS_SET_GAS_LIMIT = 27_000;\\n\\n    /// @notice Event emitted when a block root is sent to the L2\\n    /// @notice The event can be emitted multiple times for the same block root\\n    /// @notice The event can be emitted for block roots in the past\\n    /// @notice The protocol does not guarantee that the event is emitted for every block root\\n    /// @param timestamp: The timestamp of the beacon chain block\\n    /// @param blockRoot: The beacon chain block root at the given timestamp\\n    event BlockRootSent(uint256 timestamp, bytes32 blockRoot);\\n\\n    /// @notice Timestamp out of range for the the beacon roots buffer ring.\\n    error TimestampOutOfRing();\\n\\n    /// @notice Timestamp is in the future\\n    error TimestampInTheFuture();\\n\\n    /// @notice Beacont root is missing for the given timestamp.\\n    error BeaconRootMissing();\\n\\n    /// @notice The L1 official Beacon Roots contracts storing the beacon chain block roots\\n    /// @dev https://eips.ethereum.org/EIPS/eip-4788\\n    address internal constant L1_BEACON_ROOTS = 0x000F3df6D732807Ef1319fB7B8bB8522d0Beac02;\\n\\n    /// @notice The length of the beacon roots ring buffer.\\n    /// @dev https://eips.ethereum.org/EIPS/eip-4788\\n    uint256 internal constant BEACON_ROOTS_HISTORY_BUFFER_LENGTH = 8191;\\n\\n    /// @notice The number of seconds per slot in the beacon chain (12 seconds)\\n    uint256 internal constant BEACON_SECONDS_PER_SLOT = 12;\\n\\n    constructor(address _messenger, address _l2BeaconRoots) {\\n        L1_MESSENGER = IL1CrossDomainMessenger(_messenger);\\n        L2_BEACON_ROOTS = L2BeaconRoots(_l2BeaconRoots);\\n    }\\n\\n    /// @notice Sends a beacon block root to the L2\\n    /// @notice Retrieves the block root from the official beacon roots contract and sends it to the L2\\n    /// @param _timestamp: The timestamp of the beacon chain block\\n    function sendBlockRoot(uint256 _timestamp) public {\\n        uint256 currentBlockTimestamp = block.timestamp;\\n\\n        // If the _timestamp is not guaranteed to be within the beacon block root ring buffer, revert.\\n        if (_timestamp > currentBlockTimestamp) {\\n            revert TimestampInTheFuture();\\n        }\\n\\n        if ((currentBlockTimestamp - _timestamp) >= (BEACON_ROOTS_HISTORY_BUFFER_LENGTH * BEACON_SECONDS_PER_SLOT)) {\\n            revert TimestampOutOfRing();\\n        }\\n\\n        bytes32 beaconRoot = _getBlockRoot(_timestamp);\\n        if (beaconRoot == bytes32(0)) {\\n            revert BeaconRootMissing();\\n        }\\n\\n        _send(_timestamp, beaconRoot);\\n    }\\n\\n    /// @notice Sends beacon block root of the current block to the L2\\n    /// @notice Retrieves the block root from the official beacon roots contract and sends it to the L2\\n    /// @notice The beacon block root is for the parent beacon chain slot of the current block\\n    function sendCurrentBlockRoot() public {\\n        uint256 currentBlockTimestamp = block.timestamp;\\n\\n        bytes32 beaconRoot = _getBlockRoot(currentBlockTimestamp);\\n        if (beaconRoot == bytes32(0)) {\\n            revert BeaconRootMissing();\\n        }\\n\\n        _send(currentBlockTimestamp, beaconRoot);\\n    }\\n\\n    /// @notice Retrieves a beacon block root from the official beacon roots contract (EIP-4788)\\n    /// @param _timestamp: The timestamp of the beacon chain block\\n    function _getBlockRoot(uint256 _timestamp) internal view returns (bytes32 blockRoot) {\\n        (bool success, bytes memory result) = L1_BEACON_ROOTS.staticcall(abi.encode(_timestamp));\\n        if (success && result.length > 0) {\\n            return abi.decode(result, (bytes32));\\n        } else {\\n            return bytes32(0);\\n        }\\n    }\\n\\n    /// @notice Sends a beacon block root to the L2\\n    /// @param _timestamp: The timestamp of the beacon chain block\\n    /// @param _beaconRoot: The beacon chain block root at the given timestamp\\n    function _send(uint256 _timestamp, bytes32 _beaconRoot) internal {\\n        // Send the block root to the L2\\n        L1_MESSENGER.sendMessage(\\n            address(L2_BEACON_ROOTS),\\n            abi.encodeCall(L2_BEACON_ROOTS.set, (_timestamp, _beaconRoot)),\\n            L2_BEACON_ROOTS_SET_GAS_LIMIT\\n        );\\n\\n        // Emit BlockRootSent event\\n        emit BlockRootSent(_timestamp, _beaconRoot);\\n    }\\n}\\n\",\"keccak256\":\"0xc47874ee2eb189de06e66a31c6368bbffe4175c7bbc88a6b63cd8de74f1b5b99\",\"license\":\"MIT\"},\"contracts/src/L2BeaconRoots.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport \\\"./L1BeaconRootsSender.sol\\\";\\n\\n/// @title IL2CrossDomainMessenger\\n/// @notice Interface for the OP L2CrossDomainMessenger contract\\ninterface IL2CrossDomainMessenger {\\n    function xDomainMessageSender() external view returns (address);\\n}\\n\\n/// @title L2BeaconRoots\\n/// @notice The L2BeaconRoots contract stores the beacon chain block roots on the L2\\ncontract L2BeaconRoots {\\n    /// @notice The L1CrossDomainMessenger contract\\n    IL2CrossDomainMessenger public immutable MESSENGER;\\n\\n    /// @notice The L1BeaconRootsSender contract on the L1\\n    address public L1_BEACON_ROOTS_SENDER;\\n\\n    /// @notice The beacon chain block roots stored by timestamps\\n    mapping(uint256 => bytes32) public beaconRoots;\\n\\n    /// @notice Event emitted when the smart contract is initialized\\n    /// @param _l1BeaconRootsSender: The address of the L1BeaconRootsSender contract on L1\\n    event Initialized(address _l1BeaconRootsSender);\\n\\n    /// @notice Event emitted when a beacon block root is set\\n    /// @notice The event can be emitted multiple times for the same block root\\n    /// @notice The event can be emitted for block roots in the past\\n    /// @notice The protocol does not guarantee that the event is emitted for every block root\\n    /// @param timestamp: The timestamp of the beacon chain block\\n    /// @param blockRoot: The beacon chain block root at the given timestamp\\n    event BeaconRootSet(uint256 timestamp, bytes32 blockRoot);\\n\\n    /// @param _messenger: The address of the L2 CrossDomainMessenger contract\\n    constructor(address _messenger) {\\n        MESSENGER = IL2CrossDomainMessenger(_messenger);\\n    }\\n\\n    /// @notice Initialize the contract with the L1BeaconRootsSender address.\\n    /// @param _l1BeaconRootsSender: The address of the L1BeaconRootsSender contract\\n    /// @dev The flow is:\\n    ///       1) Deploy L2BeaconRoots on L2\\n    ///       2) Deploy L1BeaconRootsSender on L1 (passing the address of the deployed L2BeaconRoots to the constructor)\\n    ///       3) Initialize L2BeaconRoots with the L1BeaconRootsSender address\\n    function init(address _l1BeaconRootsSender) public {\\n        require(address(L1_BEACON_ROOTS_SENDER) == address(0), \\\"BeaconRoots: Contract has already been initialized\\\");\\n        L1_BEACON_ROOTS_SENDER = _l1BeaconRootsSender;\\n        emit Initialized(_l1BeaconRootsSender);\\n    }\\n\\n    /// @notice Sets the beacon root for a given beacon chain timestamp\\n    /// @notice This function must be called by the L1BeaconRootsSender contract on L1 through the OP CrossDomainMessenger\\n    /// @param _beaconTimestamp: The timestamp of the beacon chain block\\n    /// @param _beaconRoot: The beacon chain block root at the given timestamp\\n    function set(uint256 _beaconTimestamp, bytes32 _beaconRoot) public {\\n        require(msg.sender == address(MESSENGER), \\\"BeaconRoots: Direct sender must be the CrossDomainMessenger\\\");\\n\\n        require(\\n            MESSENGER.xDomainMessageSender() == L1_BEACON_ROOTS_SENDER,\\n            \\\"BeaconRoots: Remote sender must be the Beacon Roots Sender contract\\\"\\n        );\\n\\n        beaconRoots[_beaconTimestamp] = _beaconRoot;\\n\\n        emit BeaconRootSet(_beaconTimestamp, _beaconRoot);\\n    }\\n\\n    /// @notice Gets the beacon root for a given beacon chain timestamp\\n    /// @param _beacon_timestamp: The timestamp of the beacon chain block\\n    function get(uint256 _beacon_timestamp) public view returns (bytes32) {\\n        return beaconRoots[_beacon_timestamp];\\n    }\\n}\\n\",\"keccak256\":\"0x2dd18713386617fe1364d26609a3e08774e1c623896910fe5408c63bbb3a76d2\",\"license\":\"MIT\"},\"contracts/src/L2BeaconRootsVerifier.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport \\\"./libraries/BeaconBlockSSZMerkleProof.sol\\\";\\nimport \\\"./L2BeaconRoots.sol\\\";\\n\\n/// @title L2BeaconRootsVerifier\\n/// @notice The L2BeaconRootsVerifier contract responsible for verifyring Beacon Block SSZ Merkle proofs\\ncontract L2BeaconRootsVerifier {\\n    L2BeaconRoots public immutable L2_BEACON_ROOTS;\\n\\n    /// @param _l2BeaconRoots: The address of the L2BeaconRoots contract\\n    constructor(address _l2BeaconRoots) {\\n        L2_BEACON_ROOTS = L2BeaconRoots(_l2BeaconRoots);\\n    }\\n\\n    /// @notice Verifies a Withdrawals Root Merkle proof for a given timestamp\\n    /// @param _timestamp: The timestamp of the Beacon Block\\n    /// @param _proofs: The Merkle proof\\n    /// @param _withdrawalsRoot: The Withdrawals Root to verify\\n    function verify(uint256 _timestamp, bytes32[] memory _proofs, bytes32 _withdrawalsRoot)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        // Retrieve the Beacon Root from L2BeaconRoots\\n        bytes32 _beaconRoot = L2_BEACON_ROOTS.get(_timestamp);\\n        require(_beaconRoot != bytes32(0), \\\"L2BeaconRootsVerifier: Beacon root not found\\\");\\n\\n        // Verify the Withdrawals Root Merkle proof\\n        return BeaconBlockSSZMerkleProof._verifyWithdrawalsRootProof(_withdrawalsRoot, _proofs, _beaconRoot);\\n    }\\n}\\n\",\"keccak256\":\"0x44f5e776e8f9809bcfe0daf4322ee0c4e416fb31265e1e51b6d8204b98cb8105\",\"license\":\"MIT\"},\"contracts/src/libraries/BeaconBlockSSZMerkleProof.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport \\\"./SSZMerkleProof.sol\\\";\\n\\n/// @title BeaconBlockSSZMerkleProof\\n/// @notice Library for verifying Beacon Block SSZ Merkle proofs\\nlibrary BeaconBlockSSZMerkleProof {\\n    uint256 public constant WITHRAWAL_ROOT_GENERALIZED_INDEX = 0x192e;\\n\\n    /// @notice The depth of the Withdrawals Root in the Beacon Block SSZ Merkle tree\\n    uint256 public constant WITHRAWAL_ROOT_GENERALIZED_INDEX_DEPTH = 0xc;\\n\\n    /// @notice Verifies a Withdrawals Root Merkle proof\\n    /// @param _withdrawalsRoot: The Withdrawals Root to verify\\n    /// @param _proofs: The Merkle proof\\n    /// @param _beaconRoot: The Beacon Root to verify against\\n    /// @return True if the proof is valid, false otherwise\\n    function _verifyWithdrawalsRootProof(bytes32 _withdrawalsRoot, bytes32[] memory _proofs, bytes32 _beaconRoot)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        require(_proofs.length == WITHRAWAL_ROOT_GENERALIZED_INDEX_DEPTH, \\\"L2BeaconRootVerifier: Invalid proof length\\\");\\n        return SSZMerkleProof._verify(_proofs, _beaconRoot, _withdrawalsRoot, WITHRAWAL_ROOT_GENERALIZED_INDEX);\\n    }\\n}\\n\",\"keccak256\":\"0xfa0a681b99f993a8eee6721ceabceb977cdffa1483779bdbc01b455b8f6d71f9\",\"license\":\"MIT\"},\"contracts/src/libraries/SSZMerkleProof.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\n/// @title SSZMerkleProof\\n/// @notice Library for verifying SSZ Merkle proofs\\nlibrary SSZMerkleProof {\\n    /// @notice Verifies an SSZ Merkle proof for a branch\\n    /// @param _proofs: The Merkle proofs\\n    /// @param _root: The root hash to verify against\\n    /// @param _leaf: The leaf value to verify\\n    /// @param _index: The generalized index of the leaf in the SSZ tree\\n    function _verify(bytes32[] memory _proofs, bytes32 _root, bytes32 _leaf, uint256 _index)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        return _processProof(_proofs, _leaf, _index) == _root;\\n    }\\n\\n    /// @notice Computes the root hash of a Merkle branch in a SSZ tree\\n    /// @param _proofs: The Merkle proofs\\n    /// @param _leaf: The leaf value\\n    /// @param _index: The generalized index of the leaf in the SSZ tree\\n    function _processProof(bytes32[] memory _proofs, bytes32 _leaf, uint256 _index) internal pure returns (bytes32) {\\n        // Compute the root hash of the Merkle branch\\n        bytes32 computedHash = _leaf;\\n        for (uint256 i = 0; i < _proofs.length; i++) {\\n            // if i-th bit of WITHRAWAL_ROOT_GENERALIZED_INDEX is set to 1,\\n            // then the computedHash is the right child\\n            // otherwise it is the left child\\n            if (_index & (1 << i) == (1 << i)) {\\n                computedHash = _efficientSha256(_proofs[i], computedHash);\\n            } else {\\n                computedHash = _efficientSha256(computedHash, _proofs[i]);\\n            }\\n        }\\n        return computedHash;\\n    }\\n\\n    function _efficientSha256(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        bytes memory pack = new bytes(64);\\n        assembly {\\n            mstore(add(pack, 32), a)\\n            mstore(add(pack, 64), b)\\n        }\\n        return sha256(pack);\\n    }\\n}\\n\",\"keccak256\":\"0x575a22fc8a8e1ac24ad9e7545386c38f5eeb31ca08733aa03fb9a60a53f9829d\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60a03461007357601f6104b738819003918201601f19168301916001600160401b038311848410176100785780849260209460405283398101031261007357516001600160a01b0381169081900361007357608052604051610428908161008f823960805181818161013501526101930152f35b600080fd5b634e487b7160e01b600052604160045260246000fdfe6080604052600436101561001257600080fd5b6000803560e01c908163167580cc1461003a5750633a46ad491461003557600080fd5b61011f565b346100e45760603660031901126100e45760243567ffffffffffffffff918282116100e457366023830112156100e45781600401359283116100e7578260051b6040519260209461008d868401866100fd565b8452602485850192820101923684116100e45750602401905b8282106100d5576100d16100bf60443586600435610175565b60405190151581529081906020820190565b0390f35b813581529084019084016100a6565b80fd5b634e487b7160e01b600052604160045260246000fd5b90601f8019910116810190811067ffffffffffffffff8211176100e757604052565b34610164576000366003190112610164576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b600080fd5b6040513d6000823e3d90fd5b604051634a83e9cd60e11b81526004810191909152906020826024817f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03165afa91821561026c57600092610239575b5081156101df576101dc92610271565b90565b60405162461bcd60e51b815260206004820152602c60248201527f4c32426561636f6e526f6f747356657269666965723a20426561636f6e20726f60448201526b1bdd081b9bdd08199bdd5b9960a21b6064820152608490fd5b90916020823d8211610264575b81610253602093836100fd565b810103126100e457505190386101cc565b3d9150610246565b610169565b929192600c8251036102ff579060009283925b82518410156102f5576001841b8061192e16146000146102da576102b2906102ac8585610357565b51610381565b925b60001981146102c65760010192610284565b634e487b7160e01b85526011600452602485fd5b6102ef906102e88585610357565b5190610381565b926102b4565b9250939250501490565b60405162461bcd60e51b815260206004820152602a60248201527f4c32426561636f6e526f6f7456657269666965723a20496e76616c69642070726044820152690dedecc40d8cadccee8d60b31b6064820152608490fd5b805182101561036b5760209160051b010190565b634e487b7160e01b600052603260045260246000fd5b9060408051916060830183811067ffffffffffffffff8211176100e757825281835260209384840183368237528183015251908051908360005b8381106103e05750505090806000928101838152039060025afa1561026c5760005190565b818184010151818601520184906103bb56fea264697066735822122005b5ae347414d8690a496344485cccb870caf0cd6ff2db075d86bb250519a5ea64736f6c63430008140033",
  "deployedBytecode": "0x6080604052600436101561001257600080fd5b6000803560e01c908163167580cc1461003a5750633a46ad491461003557600080fd5b61011f565b346100e45760603660031901126100e45760243567ffffffffffffffff918282116100e457366023830112156100e45781600401359283116100e7578260051b6040519260209461008d868401866100fd565b8452602485850192820101923684116100e45750602401905b8282106100d5576100d16100bf60443586600435610175565b60405190151581529081906020820190565b0390f35b813581529084019084016100a6565b80fd5b634e487b7160e01b600052604160045260246000fd5b90601f8019910116810190811067ffffffffffffffff8211176100e757604052565b34610164576000366003190112610164576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b600080fd5b6040513d6000823e3d90fd5b604051634a83e9cd60e11b81526004810191909152906020826024817f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03165afa91821561026c57600092610239575b5081156101df576101dc92610271565b90565b60405162461bcd60e51b815260206004820152602c60248201527f4c32426561636f6e526f6f747356657269666965723a20426561636f6e20726f60448201526b1bdd081b9bdd08199bdd5b9960a21b6064820152608490fd5b90916020823d8211610264575b81610253602093836100fd565b810103126100e457505190386101cc565b3d9150610246565b610169565b929192600c8251036102ff579060009283925b82518410156102f5576001841b8061192e16146000146102da576102b2906102ac8585610357565b51610381565b925b60001981146102c65760010192610284565b634e487b7160e01b85526011600452602485fd5b6102ef906102e88585610357565b5190610381565b926102b4565b9250939250501490565b60405162461bcd60e51b815260206004820152602a60248201527f4c32426561636f6e526f6f7456657269666965723a20496e76616c69642070726044820152690dedecc40d8cadccee8d60b31b6064820152608490fd5b805182101561036b5760209160051b010190565b634e487b7160e01b600052603260045260246000fd5b9060408051916060830183811067ffffffffffffffff8211176100e757825281835260209384840183368237528183015251908051908360005b8381106103e05750505090806000928101838152039060025afa1561026c5760005190565b818184010151818601520184906103bb56fea264697066735822122005b5ae347414d8690a496344485cccb870caf0cd6ff2db075d86bb250519a5ea64736f6c63430008140033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "constructor": {
        "params": {
          "_l2BeaconRoots": ": The address of the L2BeaconRoots contract"
        }
      },
      "verify(uint256,bytes32[],bytes32)": {
        "params": {
          "_proofs": ": The Merkle proof",
          "_timestamp": ": The timestamp of the Beacon Block",
          "_withdrawalsRoot": ": The Withdrawals Root to verify"
        }
      }
    },
    "title": "L2BeaconRootsVerifier",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "verify(uint256,bytes32[],bytes32)": {
        "notice": "Verifies a Withdrawals Root Merkle proof for a given timestamp"
      }
    },
    "notice": "The L2BeaconRootsVerifier contract responsible for verifyring Beacon Block SSZ Merkle proofs",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}