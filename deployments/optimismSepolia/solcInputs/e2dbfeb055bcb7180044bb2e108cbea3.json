{
  "language": "Solidity",
  "sources": {
    "contracts/src/BeaconRootsVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./libraries/BeaconBlockSSZMerkleProof.sol\";\nimport \"./libraries/BeaconRoots.sol\";\nimport \"./interfaces/IBeaconRootsVerifier.sol\";\n\n/// @title BeaconRootsVerifier\n/// @notice The BeaconRootsVerifier contract responsible for verifyring Beacon Block SSZ Merkle proofs\ncontract BeaconRootsVerifier is IBeaconRootsVerifier {\n    /// @notice The address of the BeaconRoots contract to retrieve Beacon Block roots from\n    address internal immutable BEACON_ROOTS;\n\n    /// @param _beaconRoots: The address of the L2BeaconRoots contract\n    constructor(address _beaconRoots) {\n        BEACON_ROOTS = _beaconRoots;\n    }\n\n    /// @inheritdoc IBeaconRootsVerifier\n    function verify(uint256 _timestamp, bytes32[] memory _proofs, bytes32 _withdrawalsRoot)\n        public\n        view\n        returns (bool)\n    {\n        // Retrieve the Beacon Root from L2BeaconRoots\n        bytes32 _beaconRoot = _getBlockRoot(_timestamp);\n        require(_beaconRoot != bytes32(0), \"L2BeaconRootsVerifier: Beacon root not found\");\n\n        // Verify the Withdrawals Root Merkle proof\n        return BeaconBlockSSZMerkleProof._verifyWithdrawalsRootProof(_withdrawalsRoot, _proofs, _beaconRoot);\n    }\n\n    /// @notice Retrieves a beacon block root from the official beacon roots contract (EIP-4788)\n    /// @param _timestamp: The timestamp of the beacon chain block\n    function _getBlockRoot(uint256 _timestamp) internal view returns (bytes32 blockRoot) {\n        return BeaconRoots._get(BEACON_ROOTS, _timestamp);\n    }\n\n    /// @inheritdoc IBeaconRootsVerifier\n    function getBeaconRoots() external view returns (address) {\n        return BEACON_ROOTS;\n    }\n}\n"
    },
    "contracts/src/interfaces/IBeaconRootsVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title IBeaconRootsVerifier\n/// @notice The interface of BeaconRootsVerifier  responsible for verifying Beacon Block SSZ Merkle proofs\ninterface IBeaconRootsVerifier {\n    /// @notice Verifies a Withdrawals Root Merkle proof for a given timestamp\n    /// @param _timestamp: The timestamp of the Beacon Block\n    /// @param _proofs: The Merkle proof\n    /// @param _withdrawalsRoot: The Withdrawals Root to verify\n    function verify(uint256 _timestamp, bytes32[] memory _proofs, bytes32 _withdrawalsRoot)\n        external\n        view\n        returns (bool);\n\n    // @notice Returns the address of the BeaconRoots contract\n    function getBeaconRoots() external view returns (address);\n}\n"
    },
    "contracts/src/interfaces/IL1BeaconRootsSender.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title IL1BeaconRootsSender\n/// @notice The L1BeaconRootsSender contract sends the beacon chain block roots to the L2BeaconRoots contract on the L2\ninterface IL1BeaconRootsSender {\n    /// @notice Event emitted when a block root is sent to the L2\n    /// @notice The event can be emitted multiple times for the same block root\n    /// @notice The event can be emitted for block roots in the past\n    /// @notice The protocol does not guarantee that the event is emitted for every block root\n    /// @param timestamp: The timestamp of the beacon chain block\n    /// @param blockRoot: The beacon chain block root at the given timestamp\n    event BlockRootSent(uint256 timestamp, bytes32 blockRoot);\n\n    /// @notice Timestamp out of range for the the beacon roots buffer ring.\n    error TimestampOutOfRing();\n\n    /// @notice Timestamp is in the future\n    error TimestampInTheFuture();\n\n    /// @notice Beacont root is missing for the given timestamp.\n    error BeaconRootMissing();\n\n    /// @notice Sends a beacon block root to the L2\n    /// @notice Retrieves the block root from the official beacon roots contract and sends it to the L2\n    /// @param _timestamp: The timestamp of the beacon chain block\n    function sendBlockRoot(uint256 _timestamp) external;\n\n    /// @notice Sends beacon block root of the current block to the L2\n    /// @notice Retrieves the block root from the official beacon roots contract and sends it to the L2\n    /// @notice The beacon block root is for the parent beacon chain slot of the current block\n    function sendCurrentBlockRoot() external;\n\n    /// @notice Retrieves the address of the CrossDomainMessenger contract on the L1\n    function getCrossDomainMessenger() external view returns (address);\n\n    /// @notice Retrieves the address of the L2BeaconRoots contract on the L2\n    function getL2BeaconRoots() external view returns (address);\n}\n"
    },
    "contracts/src/interfaces/IL1CrossDomainMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title IL1CrossDomainMessenger\n/// @notice Interface of the OP CrossDomainMessenger contract on the L1\ninterface IL1CrossDomainMessenger {\n    function sendMessage(address _target, bytes calldata _message, uint32 _gasLimit) external;\n}\n"
    },
    "contracts/src/interfaces/IL2BeaconRoots.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title IL2BeaconRoots\n/// @notice The interface of the L2BeaconRoots contract stores the beacon chain block roots on the L2\ninterface IL2BeaconRoots {\n    /// @notice Event emitted when the smart contract is initialized\n    /// @param _l1BeaconRootsSender: The address of the L1BeaconRootsSender contract on L1\n    event Initialized(address _l1BeaconRootsSender);\n\n    /// @notice Event emitted when a beacon block root is set\n    /// @notice The event can be emitted multiple times for the same block root\n    /// @notice The event can be emitted for block roots in the past\n    /// @notice The protocol does not guarantee that the event is emitted for every block root\n    /// @param timestamp: The timestamp of the beacon chain block\n    /// @param blockRoot: The beacon chain block root at the given timestamp\n    event BeaconRootSet(uint256 timestamp, bytes32 blockRoot);\n\n    /// @notice Initialize the contract with the L1BeaconRootsSender address.\n    /// @param _l1BeaconRootsSender: The address of the L1BeaconRootsSender contract\n    /// @dev The flow is:\n    ///       1) Deploy L2BeaconRoots on L2\n    ///       2) Deploy L1BeaconRootsSender on L1 (passing the address of the deployed L2BeaconRoots to the constructor)\n    ///       3) Initialize L2BeaconRoots with the L1BeaconRootsSender address\n    function init(address _l1BeaconRootsSender) external;\n\n    /// @notice Sets the beacon root for a given beacon chain timestamp\n    /// @notice This function must be called by the L1BeaconRootsSender contract on L1 through the OP CrossDomainMessenger\n    /// @param _beaconTimestamp: The timestamp of the beacon chain block\n    /// @param _beaconRoot: The beacon chain block root at the given timestamp\n    function set(uint256 _beaconTimestamp, bytes32 _beaconRoot) external;\n\n    /// @notice Gets the beacon root for a given beacon chain timestamp\n    /// @param _beacon_timestamp: The timestamp of the beacon chain block\n    function get(uint256 _beacon_timestamp) external view returns (bytes32);\n\n    /// @notice Retrieves the address of the CrossDomainMessenger contract on the L2\n    function getCrossDomainMessenger() external view returns (address);\n\n    /// @notice Retrieves the address of the L1BeaconRootsSender contract on the L1\n    function getL1BeaconRootsSender() external view returns (address);\n}\n"
    },
    "contracts/src/interfaces/IL2CrossDomainMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title IL2CrossDomainMessenger\n/// @notice Interface for the OP CrossDomainMessenger contract on L2\ninterface IL2CrossDomainMessenger {\n    function xDomainMessageSender() external view returns (address);\n}\n"
    },
    "contracts/src/L1BeaconRootsSender.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./libraries/BeaconRoots.sol\";\nimport \"./state/BeaconRootsRingTracker.sol\";\nimport \"./interfaces/IL1CrossDomainMessenger.sol\";\nimport \"./interfaces/IL1BeaconRootsSender.sol\";\nimport \"./interfaces/IL2BeaconRoots.sol\";\n\n/// @title L1BeaconRootsSender\n/// @notice The L1BeaconRootsSender contract sends the beacon chain block roots to the L2BeaconRoots contract on the L2\ncontract L1BeaconRootsSender is IL1BeaconRootsSender {\n    /// @notice The OP L1CrossDomainMessenger contract\n    address internal immutable MESSENGER;\n\n    /// @notice The L2BeaconRoots contract on the L2\n    address internal immutable L2_BEACON_ROOTS;\n\n    /// @notice The L1 official Beacon Roots contracts storing the beacon chain block roots\n    /// @dev https://eips.ethereum.org/EIPS/eip-4788\n    address internal constant BEACON_ROOTS = 0x000F3df6D732807Ef1319fB7B8bB8522d0Beac02;\n\n    /// @notice The length of the beacon roots ring buffer.\n    /// @dev https://eips.ethereum.org/EIPS/eip-4788\n    uint256 internal constant BEACON_ROOTS_HISTORY_BUFFER_LENGTH = 8191;\n\n    /// @notice The number of seconds per slot in the beacon chain (12 seconds)\n    uint256 internal constant BEACON_SECONDS_PER_SLOT = 12;\n\n    /// @notice The gas limit required for executing the L2BeaconRoots.set call on L2 varies based on whether\n    ///         a beacon root has already been stored in the L2BeaconRoots ring buffer for the specified timestamp.\n    ///         Most of the gas cost is due to two SSTORE operations (one for the timestamp and one for the beacon root):\n    ///             - 20,000 gas each when writing to cold storage.\n    ///             - 2,900 gas each when writing to warm storage.\n    uint32 internal constant L2_BEACON_ROOTS_SET_GAS_LIMIT_WHEN_COLD = 50_000;\n    uint32 internal constant L2_BEACON_ROOTS_SET_GAS_LIMIT_WHEN_WARM = 15_000;\n\n    /// @param _messenger: The address of the CrossDomainMessenger contract on the L1\n    /// @param _l2BeaconRoots: The address of the L2BeaconRoots contract on the L2\n    constructor(address _messenger, address _l2BeaconRoots) {\n        MESSENGER = _messenger;\n        L2_BEACON_ROOTS = _l2BeaconRoots;\n    }\n\n    /// @inheritdoc IL1BeaconRootsSender\n    function sendBlockRoot(uint256 _timestamp) public {\n        uint256 currentBlockTimestamp = block.timestamp;\n\n        // If the _timestamp is in the futre, revert.\n        if (_timestamp > currentBlockTimestamp) {\n            revert TimestampInTheFuture();\n        }\n\n        // If the _timestamp is not guaranteed to be within the beacon block root ring buffer, revert.\n        if ((currentBlockTimestamp - _timestamp) >= (BEACON_ROOTS_HISTORY_BUFFER_LENGTH * BEACON_SECONDS_PER_SLOT)) {\n            revert TimestampOutOfRing();\n        }\n\n        // Retrieve the beacon block root from the official beacon roots contract\n        bytes32 beaconRoot = _getBlockRoot(_timestamp);\n\n        // If the beacon root is missing, revert.\n        if (beaconRoot == bytes32(0)) {\n            revert BeaconRootMissing();\n        }\n\n        // Send the beacon block root to the L2\n        _send(_timestamp, beaconRoot);\n    }\n\n    /// @inheritdoc IL1BeaconRootsSender\n    function sendCurrentBlockRoot() public {\n        uint256 currentBlockTimestamp = block.timestamp;\n\n        // Retrieve the beacon block root from the official beacon roots contract\n        bytes32 beaconRoot = _getBlockRoot(currentBlockTimestamp);\n\n        // If the beacon root is missing, revert.\n        if (beaconRoot == bytes32(0)) {\n            revert BeaconRootMissing();\n        }\n\n        // Send the beacon block root to the L2\n        _send(currentBlockTimestamp, beaconRoot);\n    }\n\n    /// @notice Retrieves a beacon block root from the official beacon roots contract (EIP-4788)\n    /// @param _timestamp: The timestamp of the beacon chain block\n    function _getBlockRoot(uint256 _timestamp) internal view returns (bytes32 blockRoot) {\n        return BeaconRoots._get(BEACON_ROOTS, _timestamp);\n    }\n\n    /// @notice Sends a beacon block root to the L2\n    /// @param _timestamp: The timestamp of the beacon chain block\n    /// @param _beaconRoot: The beacon chain block root at the given timestamp\n    function _send(uint256 _timestamp, bytes32 _beaconRoot) internal {\n        // Check whether a beacon root has already been set in the L2BeaconRoots ring buffer for the specified timestamp.\n        // It is used to adjust the gas limit required for the L2BeaconRoots.set call on L2.\n        // If not previously set, the timestamp is marked accordingly.\n        bool isToBeSet = BeaconRootsRingTracker._markIfNotYetMarked(_timestamp % BEACON_ROOTS_HISTORY_BUFFER_LENGTH);\n\n        // If a beacon root has already been set in the L2BeaconRoots ring buffer for the specified timestamp,\n        // a lower gas limit is used since there's no need to write to fresh storage.\n        // Otherwise, the higher gas limit is applied for initial writes.\n        // As more beacon roots are recorded over time, the gas limit will increasingly shift to the warm limit.\n        // This approach reduces the L1 gas required to send beacon roots through the OP CrossDomainMessenger.\n        uint32 gasLimit = L2_BEACON_ROOTS_SET_GAS_LIMIT_WHEN_WARM;\n        if (isToBeSet) {\n            gasLimit = L2_BEACON_ROOTS_SET_GAS_LIMIT_WHEN_COLD;\n        }\n\n        // Send the beacon block root to the L2\n        IL1CrossDomainMessenger(MESSENGER).sendMessage(\n            address(L2_BEACON_ROOTS), abi.encodeCall(IL2BeaconRoots.set, (_timestamp, _beaconRoot)), gasLimit\n        );\n\n        // Emit BlockRootSent event\n        emit BlockRootSent(_timestamp, _beaconRoot);\n    }\n\n    /// @inheritdoc IL1BeaconRootsSender\n    function getCrossDomainMessenger() external view returns (address) {\n        return MESSENGER;\n    }\n\n    /// @inheritdoc IL1BeaconRootsSender\n    function getL2BeaconRoots() external view returns (address) {\n        return L2_BEACON_ROOTS;\n    }\n}\n"
    },
    "contracts/src/L2BeaconRoots.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./interfaces/IL2CrossDomainMessenger.sol\";\nimport \"./interfaces/IL1BeaconRootsSender.sol\";\nimport \"./interfaces/IL2BeaconRoots.sol\";\nimport \"./state/BeaconRootsBuffer.sol\";\n\n/// @title L2BeaconRoots\n/// @notice The L2BeaconRoots contract stores the beacon chain block roots on the L2\n///         It uses a ring buffer to store the block roots for up to the last 8191 beacon chain blocks\ncontract L2BeaconRoots is IL2BeaconRoots {\n    /// @notice The L1CrossDomainMessenger contract\n    address internal immutable MESSENGER;\n\n    /// @notice The L1BeaconRootsSender contract on the L1\n    address internal L1_BEACON_ROOTS_SENDER;\n\n    /// @param _messenger: The address of the L2 CrossDomainMessenger contract\n    constructor(address _messenger) {\n        MESSENGER = _messenger;\n    }\n\n    /// @inheritdoc IL2BeaconRoots\n    function init(address _l1BeaconRootsSender) public {\n        require(L1_BEACON_ROOTS_SENDER == address(0), \"BeaconRoots: Contract has already been initialized\");\n        L1_BEACON_ROOTS_SENDER = _l1BeaconRootsSender;\n        emit Initialized(_l1BeaconRootsSender);\n    }\n\n    /// @inheritdoc IL2BeaconRoots\n    function set(uint256 _beaconTimestamp, bytes32 _beaconRoot) public {\n        require(msg.sender == MESSENGER, \"BeaconRoots: Direct sender must be the CrossDomainMessenger\");\n\n        require(\n            IL2CrossDomainMessenger(MESSENGER).xDomainMessageSender() == L1_BEACON_ROOTS_SENDER,\n            \"BeaconRoots: Remote sender must be the Beacon Roots Sender contract\"\n        );\n\n        _set(_beaconTimestamp, _beaconRoot);\n    }\n\n    /// @inheritdoc IL2BeaconRoots\n    function get(uint256 _beacon_timestamp) public view returns (bytes32) {\n        return _get(_beacon_timestamp);\n    }\n\n    /// @inheritdoc IL2BeaconRoots\n    function getCrossDomainMessenger() external view returns (address) {\n        return MESSENGER;\n    }\n\n    /// @inheritdoc IL2BeaconRoots\n    function getL1BeaconRootsSender() external view returns (address) {\n        return L1_BEACON_ROOTS_SENDER;\n    }\n\n    /// @notice Set a beacon block root\n    /// @param _beaconTimestamp: The timestamp of the beacon block\n    function _set(uint256 _beaconTimestamp, bytes32 _beaconRoot) internal {\n        BeaconRootsBuffer._set(_beaconTimestamp, _beaconRoot);\n        emit BeaconRootSet(_beaconTimestamp, _beaconRoot);\n    }\n\n    /// @notice Retrieves a beacon block root\n    /// @param _beaconTimestamp: The timestamp of the beacon block\n    function _get(uint256 _beaconTimestamp) internal view returns (bytes32) {\n        return BeaconRootsBuffer._get(_beaconTimestamp);\n    }\n\n    /// @notice Fallback function mirorring the official BeaconRoots contract (EIP-4788)\n    /// @notice It expects calldata to be a beacon root timestamp encoded on 32 bytes and\n    ///         it returns a bytes32 beacon root\n    fallback() external {\n        // If calldata is not 32 bytes long, revert\n        require(msg.data.length == 32, \"BeaconRoots: Invalid function selector\");\n\n        // Convert the call data to a uint256\n        uint256 beaconTimestamp;\n        assembly {\n            beaconTimestamp := calldataload(0)\n        }\n\n        // Retrieve the beacon root\n        bytes32 beaconRoot = _get(beaconTimestamp);\n\n        // Return the beacon root\n        assembly {\n            mstore(0, beaconRoot)\n            return(0, 32)\n        }\n    }\n}\n"
    },
    "contracts/src/libraries/BeaconBlockSSZMerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./SSZMerkleProof.sol\";\n\n/// @title BeaconBlockSSZMerkleProof\n/// @notice Library for verifying Beacon Block SSZ Merkle proofs\nlibrary BeaconBlockSSZMerkleProof {\n    uint256 public constant WITHRAWAL_ROOT_GENERALIZED_INDEX = 0x192e;\n\n    /// @notice The depth of the Withdrawals Root in the Beacon Block SSZ Merkle tree\n    uint256 public constant WITHRAWAL_ROOT_GENERALIZED_INDEX_DEPTH = 0xc;\n\n    /// @notice Verifies a Withdrawals Root Merkle proof\n    /// @param _withdrawalsRoot: The Withdrawals Root to verify\n    /// @param _proofs: The Merkle proof\n    /// @param _beaconRoot: The Beacon Root to verify against\n    /// @return True if the proof is valid, false otherwise\n    function _verifyWithdrawalsRootProof(bytes32 _withdrawalsRoot, bytes32[] memory _proofs, bytes32 _beaconRoot)\n        internal\n        pure\n        returns (bool)\n    {\n        require(_proofs.length == WITHRAWAL_ROOT_GENERALIZED_INDEX_DEPTH, \"L2BeaconRootVerifier: Invalid proof length\");\n        return SSZMerkleProof._verify(_proofs, _beaconRoot, _withdrawalsRoot, WITHRAWAL_ROOT_GENERALIZED_INDEX);\n    }\n}\n"
    },
    "contracts/src/libraries/BeaconRoots.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title SSZMerkleProof\n/// @notice Library for verifying SSZ Merkle proofs\nlibrary BeaconRoots {\n    function _get(address _beaconRoots, uint256 _timestamp) internal view returns (bytes32) {\n        (bool success, bytes memory result) = _beaconRoots.staticcall(abi.encode(_timestamp));\n        if (success && result.length > 0) {\n            return abi.decode(result, (bytes32));\n        } else {\n            return bytes32(0);\n        }\n    }\n}\n"
    },
    "contracts/src/libraries/SSZMerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title SSZMerkleProof\n/// @notice Library for verifying SSZ Merkle proofs\nlibrary SSZMerkleProof {\n    /// @notice Verifies an SSZ Merkle proof for a branch\n    /// @param _proofs: The Merkle proofs\n    /// @param _root: The root hash to verify against\n    /// @param _leaf: The leaf value to verify\n    /// @param _index: The generalized index of the leaf in the SSZ tree\n    function _verify(bytes32[] memory _proofs, bytes32 _root, bytes32 _leaf, uint256 _index)\n        internal\n        pure\n        returns (bool)\n    {\n        return _processProof(_proofs, _leaf, _index) == _root;\n    }\n\n    /// @notice Computes the root hash of a Merkle branch in a SSZ tree\n    /// @param _proofs: The Merkle proofs\n    /// @param _leaf: The leaf value\n    /// @param _index: The generalized index of the leaf in the SSZ tree\n    function _processProof(bytes32[] memory _proofs, bytes32 _leaf, uint256 _index) internal pure returns (bytes32) {\n        // Compute the root hash of the Merkle branch\n        bytes32 computedHash = _leaf;\n        for (uint256 i = 0; i < _proofs.length; i++) {\n            // if i-th bit of WITHRAWAL_ROOT_GENERALIZED_INDEX is set to 1,\n            // then the computedHash is the right child\n            // otherwise it is the left child\n            if (_index & (1 << i) == (1 << i)) {\n                computedHash = _efficientSha256(_proofs[i], computedHash);\n            } else {\n                computedHash = _efficientSha256(computedHash, _proofs[i]);\n            }\n        }\n        return computedHash;\n    }\n\n    function _efficientSha256(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        bytes memory pack = new bytes(64);\n        assembly {\n            mstore(add(pack, 32), a)\n            mstore(add(pack, 64), b)\n        }\n        return sha256(pack);\n    }\n}\n"
    },
    "contracts/src/state/BeaconRootsBuffer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title BeaconRootsBuffer Storage\n/// @notice Utility to manage the BeaconRootsBuffer in storage.\n/// @notice It keeps a history of beacon roots for 8191 blocks which is around 1 day.\n///         The buffer enables to save gas by rewriting beaconRoots on warm storage slots.\nlibrary BeaconRootsBuffer {\n    /// @notice Storage slot of the buffer\n    bytes32 internal constant BUFFER_SLOT = bytes32(uint256(keccak256(\"beaconRoots.state.buffer\")) - 1);\n\n    /// @notice Length of the history buffer\n    uint256 internal constant HISTORY_BUFFER_LENGTH = 8191;\n\n    /// @notice Structure of the buffer in storage\n    struct Slot {\n        mapping(uint256 => uint256) value;\n    }\n\n    /// @notice Set a beacon root in the buffer\n    /// @param _timestamp The timestamp of the beacon root\n    /// @param _beaconRoot The beacon root\n    function _set(uint256 _timestamp, bytes32 _beaconRoot) internal {\n        bytes32 slot = BUFFER_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        uint256 timestamp_idx = _timestamp % HISTORY_BUFFER_LENGTH;\n        uint256 root_idx = timestamp_idx + HISTORY_BUFFER_LENGTH;\n        r.value[timestamp_idx] = _timestamp;\n        r.value[root_idx] = uint256(_beaconRoot);\n    }\n\n    /// @notice Get a beacon root from the buffer\n    /// @param _timestamp The timestamp of the beacon root\n    /// @return beaconRoot The beacon root if found, otherwise 0\n    function _get(uint256 _timestamp) internal view returns (bytes32 beaconRoot) {\n        bytes32 slot = BUFFER_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        uint256 timestamp_idx = _timestamp % HISTORY_BUFFER_LENGTH;\n        uint256 root_idx = timestamp_idx + HISTORY_BUFFER_LENGTH;\n\n        uint256 bufferTimestamp = r.value[timestamp_idx];\n        if (bufferTimestamp == _timestamp) {\n            beaconRoot = bytes32(r.value[root_idx]);\n        }\n    }\n}\n"
    },
    "contracts/src/state/BeaconRootsRingTracker.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title BeaconRootsBuffer Storage\n/// @notice Utility to track the state of the L2BeaconRoots ring buffer\nlibrary BeaconRootsRingTracker {\n    /// @notice Storage slot of the buffer\n    bytes32 internal constant RING_TRACKER_SLOT = bytes32(uint256(keccak256(\"beaconRootsSender.state.ringTracker\")) - 1);\n\n    /// @notice Structure of the buffer in storage\n    struct Slot {\n        uint256[32] value;\n    }\n\n    /// @notice Check if a ring buffer index was already marked\n    /// @param _ringIdx: The ring buffer index, it must be within the history buffer length (0 <= _ringIdx < HISTORY_BUFFER_LENGTH)\n    function _isMarked(uint256 _ringIdx) internal view returns (bool) {\n        bytes32 slot = RING_TRACKER_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        (uint256 trackerIdx, uint256 bitIdx) = _position(_ringIdx);\n\n        return r.value[trackerIdx] & (1 << bitIdx) > 0;\n    }\n\n    /// @notice Mark a ring buffer index if it is was not already marked\n    /// @param _ringIdx: The ring buffer index, it must be within the history buffer length (0 <= _ringIdx < HISTORY_BUFFER_LENGTH)\n    /// @return true if the marking happen, or false if the index was already marked\n    function _markIfNotYetMarked(uint256 _ringIdx) internal returns (bool) {\n        bytes32 slot = RING_TRACKER_SLOT;\n\n        Slot storage r;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r.slot := slot\n        }\n\n        /// Check if the ring index is already marked\n        (uint256 trackerIdx, uint256 bitIdx) = _position(_ringIdx);\n        if (r.value[trackerIdx] & (1 << bitIdx) > 0) {\n            return false;\n        }\n\n        ///  Mark the ring index if it is not already marked\n        ///  Note:\n        ///  - This is the expensive part of the operation as it requires an SSTORE operation\n        ///  - In most cases, this will re-write a storage slot that was already marked for a neighboring ring index, thus reducing gas cost\n        r.value[trackerIdx] |= (1 << bitIdx);\n\n        return true;\n    }\n\n    function _position(uint256 _ringIdx) private pure returns (uint256, uint256) {\n        return (_ringIdx / 256, _ringIdx % 256);\n    }\n}\n"
    }
  },
  "settings": {
    "viaIR": true,
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}