{
  "language": "Solidity",
  "sources": {
    "contracts/src/L1BeaconRootsSender.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./L2BeaconRoots.sol\";\n\n/// @title IL1CrossDomainMessenger\n/// @notice Interface for the OP L1CrossDomainMessenger contract\ninterface IL1CrossDomainMessenger {\n    function sendMessage(address _target, bytes calldata _message, uint32 _gasLimit) external;\n}\n\n/// @title L1BeaconRootsSender\n/// @notice The L1BeaconRootsSender contract sends the beacon chain block roots to the L2BeaconRoots contract on the L2\ncontract L1BeaconRootsSender {\n    /// @notice The OP L1CrossDomainMessenger contract\n    IL1CrossDomainMessenger public immutable L1_MESSENGER;\n\n    /// @notice The L2BeaconRoots contract on the L2\n    L2BeaconRoots public immutable L2_BEACON_ROOTS;\n\n    /// @notice The required gas limit for executing the set function on the L2BeaconRoots contract\n    uint32 public constant L2_BEACON_ROOTS_SET_GAS_LIMIT = 27_000;\n\n    /// @notice Event emitted when a block root is sent to the L2\n    /// @notice The event can be emitted multiple times for the same block root\n    /// @notice The event can be emitted for block roots in the past\n    /// @notice The protocol does not guarantee that the event is emitted for every block root\n    /// @param timestamp: The timestamp of the beacon chain block\n    /// @param blockRoot: The beacon chain block root at the given timestamp\n    event BlockRootSent(uint256 timestamp, bytes32 blockRoot);\n\n    /// @notice Timestamp out of range for the the beacon roots buffer ring.\n    error TimestampOutOfRing();\n\n    /// @notice Timestamp is in the future\n    error TimestampInTheFuture();\n\n    /// @notice Beacont root is missing for the given timestamp.\n    error BeaconRootMissing();\n\n    /// @notice The L1 official Beacon Roots contracts storing the beacon chain block roots\n    /// @dev https://eips.ethereum.org/EIPS/eip-4788\n    address internal constant L1_BEACON_ROOTS = 0x000F3df6D732807Ef1319fB7B8bB8522d0Beac02;\n\n    /// @notice The length of the beacon roots ring buffer.\n    /// @dev https://eips.ethereum.org/EIPS/eip-4788\n    uint256 internal constant BEACON_ROOTS_HISTORY_BUFFER_LENGTH = 8191;\n\n    /// @notice The number of seconds per slot in the beacon chain (12 seconds)\n    uint256 internal constant BEACON_SECONDS_PER_SLOT = 12;\n\n    constructor(address _messenger, address _l2BeaconRoots) {\n        L1_MESSENGER = IL1CrossDomainMessenger(_messenger);\n        L2_BEACON_ROOTS = L2BeaconRoots(_l2BeaconRoots);\n    }\n\n    /// @notice Sends a beacon block root to the L2\n    /// @notice Retrieves the block root from the official beacon roots contract and sends it to the L2\n    /// @param _timestamp: The timestamp of the beacon chain block\n    function sendBlockRoot(uint256 _timestamp) public {\n        uint256 currentBlockTimestamp = block.timestamp;\n\n        // If the _timestamp is not guaranteed to be within the beacon block root ring buffer, revert.\n        if (_timestamp > currentBlockTimestamp) {\n            revert TimestampInTheFuture();\n        }\n\n        if ((currentBlockTimestamp - _timestamp) >= (BEACON_ROOTS_HISTORY_BUFFER_LENGTH * BEACON_SECONDS_PER_SLOT)) {\n            revert TimestampOutOfRing();\n        }\n\n        bytes32 beaconRoot = _getBlockRoot(_timestamp);\n        if (beaconRoot == bytes32(0)) {\n            revert BeaconRootMissing();\n        }\n\n        _send(_timestamp, beaconRoot);\n    }\n\n    /// @notice Sends beacon block root of the current block to the L2\n    /// @notice Retrieves the block root from the official beacon roots contract and sends it to the L2\n    /// @notice The beacon block root is for the parent beacon chain slot of the current block\n    function sendCurrentBlockRoot() public {\n        uint256 currentBlockTimestamp = block.timestamp;\n\n        bytes32 beaconRoot = _getBlockRoot(currentBlockTimestamp);\n        if (beaconRoot == bytes32(0)) {\n            revert BeaconRootMissing();\n        }\n\n        _send(currentBlockTimestamp, beaconRoot);\n    }\n\n    /// @notice Retrieves a beacon block root from the official beacon roots contract (EIP-4788)\n    /// @param _timestamp: The timestamp of the beacon chain block\n    function _getBlockRoot(uint256 _timestamp) internal view returns (bytes32 blockRoot) {\n        (bool success, bytes memory result) = L1_BEACON_ROOTS.staticcall(abi.encode(_timestamp));\n        if (success && result.length > 0) {\n            return abi.decode(result, (bytes32));\n        } else {\n            return bytes32(0);\n        }\n    }\n\n    /// @notice Sends a beacon block root to the L2\n    /// @param _timestamp: The timestamp of the beacon chain block\n    /// @param _beaconRoot: The beacon chain block root at the given timestamp\n    function _send(uint256 _timestamp, bytes32 _beaconRoot) internal {\n        // Send the block root to the L2\n        L1_MESSENGER.sendMessage(\n            address(L2_BEACON_ROOTS),\n            abi.encodeCall(L2_BEACON_ROOTS.set, (_timestamp, _beaconRoot)),\n            L2_BEACON_ROOTS_SET_GAS_LIMIT\n        );\n\n        // Emit BlockRootSent event\n        emit BlockRootSent(_timestamp, _beaconRoot);\n    }\n}\n"
    },
    "contracts/src/L2BeaconRoots.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./L1BeaconRootsSender.sol\";\n\n/// @title IL2CrossDomainMessenger\n/// @notice Interface for the OP L2CrossDomainMessenger contract\ninterface IL2CrossDomainMessenger {\n    function xDomainMessageSender() external view returns (address);\n}\n\n/// @title L2BeaconRoots\n/// @notice The L2BeaconRoots contract stores the beacon chain block roots on the L2\ncontract L2BeaconRoots {\n    /// @notice The L1CrossDomainMessenger contract\n    IL2CrossDomainMessenger public immutable MESSENGER;\n\n    /// @notice The L1BeaconRootsSender contract on the L1\n    address public L1_BEACON_ROOTS_SENDER;\n\n    /// @notice The beacon chain block roots stored by timestamps\n    mapping(uint256 => bytes32) public beaconRoots;\n\n    /// @notice Event emitted when the smart contract is initialized\n    /// @param _l1BeaconRootsSender: The address of the L1BeaconRootsSender contract on L1\n    event Initialized(address _l1BeaconRootsSender);\n\n    /// @notice Event emitted when a beacon block root is set\n    /// @notice The event can be emitted multiple times for the same block root\n    /// @notice The event can be emitted for block roots in the past\n    /// @notice The protocol does not guarantee that the event is emitted for every block root\n    /// @param timestamp: The timestamp of the beacon chain block\n    /// @param blockRoot: The beacon chain block root at the given timestamp\n    event BeaconRootSet(uint256 timestamp, bytes32 blockRoot);\n\n    /// @param _messenger: The address of the L2 CrossDomainMessenger contract\n    constructor(address _messenger) {\n        MESSENGER = IL2CrossDomainMessenger(_messenger);\n    }\n\n    /// @notice Initialize the contract with the L1BeaconRootsSender address.\n    /// @param _l1BeaconRootsSender: The address of the L1BeaconRootsSender contract\n    /// @dev The flow is:\n    ///       1) Deploy L2BeaconRoots on L2\n    ///       2) Deploy L1BeaconRootsSender on L1 (passing the address of the deployed L2BeaconRoots to the constructor)\n    ///       3) Initialize L2BeaconRoots with the L1BeaconRootsSender address\n    function init(address _l1BeaconRootsSender) public {\n        require(address(L1_BEACON_ROOTS_SENDER) == address(0), \"BeaconRoots: Contract has already been initialized\");\n        L1_BEACON_ROOTS_SENDER = _l1BeaconRootsSender;\n        emit Initialized(_l1BeaconRootsSender);\n    }\n\n    /// @notice Sets the beacon root for a given beacon chain timestamp\n    /// @notice This function must be called by the L1BeaconRootsSender contract on L1 through the OP CrossDomainMessenger\n    /// @param _beaconTimestamp: The timestamp of the beacon chain block\n    /// @param _beaconRoot: The beacon chain block root at the given timestamp\n    function set(uint256 _beaconTimestamp, bytes32 _beaconRoot) public {\n        require(msg.sender == address(MESSENGER), \"BeaconRoots: Direct sender must be the CrossDomainMessenger\");\n\n        require(\n            MESSENGER.xDomainMessageSender() == L1_BEACON_ROOTS_SENDER,\n            \"BeaconRoots: Remote sender must be the Beacon Roots Sender contract\"\n        );\n\n        beaconRoots[_beaconTimestamp] = _beaconRoot;\n\n        emit BeaconRootSet(_beaconTimestamp, _beaconRoot);\n    }\n\n    /// @notice Gets the beacon root for a given beacon chain timestamp\n    /// @param _beacon_timestamp: The timestamp of the beacon chain block\n    function get(uint256 _beacon_timestamp) public view returns (bytes32) {\n        return beaconRoots[_beacon_timestamp];\n    }\n}\n"
    },
    "contracts/src/L2BeaconRootsVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./libraries/BeaconBlockSSZMerkleProof.sol\";\nimport \"./L2BeaconRoots.sol\";\n\n/// @title L2BeaconRootsVerifier\n/// @notice The L2BeaconRootsVerifier contract responsible for verifyring Beacon Block SSZ Merkle proofs\ncontract L2BeaconRootsVerifier {\n    L2BeaconRoots public immutable L2_BEACON_ROOTS;\n\n    /// @param _l2BeaconRoots: The address of the L2BeaconRoots contract\n    constructor(address _l2BeaconRoots) {\n        L2_BEACON_ROOTS = L2BeaconRoots(_l2BeaconRoots);\n    }\n\n    /// @notice Verifies a Withdrawals Root Merkle proof for a given timestamp\n    /// @param _timestamp: The timestamp of the Beacon Block\n    /// @param _proofs: The Merkle proof\n    /// @param _withdrawalsRoot: The Withdrawals Root to verify\n    function verify(uint256 _timestamp, bytes32[] memory _proofs, bytes32 _withdrawalsRoot)\n        public\n        view\n        returns (bool)\n    {\n        // Retrieve the Beacon Root from L2BeaconRoots\n        bytes32 _beaconRoot = L2_BEACON_ROOTS.get(_timestamp);\n        require(_beaconRoot != bytes32(0), \"L2BeaconRootsVerifier: Beacon root not found\");\n\n        // Verify the Withdrawals Root Merkle proof\n        return BeaconBlockSSZMerkleProof._verifyWithdrawalsRootProof(_withdrawalsRoot, _proofs, _beaconRoot);\n    }\n}\n"
    },
    "contracts/src/libraries/BeaconBlockSSZMerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./SSZMerkleProof.sol\";\n\n/// @title BeaconBlockSSZMerkleProof\n/// @notice Library for verifying Beacon Block SSZ Merkle proofs\nlibrary BeaconBlockSSZMerkleProof {\n    uint256 public constant WITHRAWAL_ROOT_GENERALIZED_INDEX = 0x192e;\n\n    /// @notice The depth of the Withdrawals Root in the Beacon Block SSZ Merkle tree\n    uint256 public constant WITHRAWAL_ROOT_GENERALIZED_INDEX_DEPTH = 0xc;\n\n    /// @notice Verifies a Withdrawals Root Merkle proof\n    /// @param _withdrawalsRoot: The Withdrawals Root to verify\n    /// @param _proofs: The Merkle proof\n    /// @param _beaconRoot: The Beacon Root to verify against\n    /// @return True if the proof is valid, false otherwise\n    function _verifyWithdrawalsRootProof(bytes32 _withdrawalsRoot, bytes32[] memory _proofs, bytes32 _beaconRoot)\n        internal\n        pure\n        returns (bool)\n    {\n        require(_proofs.length == WITHRAWAL_ROOT_GENERALIZED_INDEX_DEPTH, \"L2BeaconRootVerifier: Invalid proof length\");\n        return SSZMerkleProof._verify(_proofs, _beaconRoot, _withdrawalsRoot, WITHRAWAL_ROOT_GENERALIZED_INDEX);\n    }\n}\n"
    },
    "contracts/src/libraries/SSZMerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title SSZMerkleProof\n/// @notice Library for verifying SSZ Merkle proofs\nlibrary SSZMerkleProof {\n    /// @notice Verifies an SSZ Merkle proof for a branch\n    /// @param _proofs: The Merkle proofs\n    /// @param _root: The root hash to verify against\n    /// @param _leaf: The leaf value to verify\n    /// @param _index: The generalized index of the leaf in the SSZ tree\n    function _verify(bytes32[] memory _proofs, bytes32 _root, bytes32 _leaf, uint256 _index)\n        internal\n        pure\n        returns (bool)\n    {\n        return _processProof(_proofs, _leaf, _index) == _root;\n    }\n\n    /// @notice Computes the root hash of a Merkle branch in a SSZ tree\n    /// @param _proofs: The Merkle proofs\n    /// @param _leaf: The leaf value\n    /// @param _index: The generalized index of the leaf in the SSZ tree\n    function _processProof(bytes32[] memory _proofs, bytes32 _leaf, uint256 _index) internal pure returns (bytes32) {\n        // Compute the root hash of the Merkle branch\n        bytes32 computedHash = _leaf;\n        for (uint256 i = 0; i < _proofs.length; i++) {\n            // if i-th bit of WITHRAWAL_ROOT_GENERALIZED_INDEX is set to 1,\n            // then the computedHash is the right child\n            // otherwise it is the left child\n            if (_index & (1 << i) == (1 << i)) {\n                computedHash = _efficientSha256(_proofs[i], computedHash);\n            } else {\n                computedHash = _efficientSha256(computedHash, _proofs[i]);\n            }\n        }\n        return computedHash;\n    }\n\n    function _efficientSha256(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        bytes memory pack = new bytes(64);\n        assembly {\n            mstore(add(pack, 32), a)\n            mstore(add(pack, 64), b)\n        }\n        return sha256(pack);\n    }\n}\n"
    }
  },
  "settings": {
    "viaIR": true,
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}