{
  "language": "Solidity",
  "sources": {
    "contracts/src/L1BeaconRootsSender.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./L2BeaconRoots.sol\";\n\n/// @title IL1CrossDomainMessenger\n/// @notice Interface for the OP L1CrossDomainMessenger contract\ninterface IL1CrossDomainMessenger {\n    function sendMessage(address _target, bytes calldata _message, uint32 _gasLimit) external;\n}\n\n/// @title L1BeaconRootsSender\n/// @notice The L1BeaconRootsSender contract sends the beacon chain block roots to the L2BeaconRoots contract on the L2\ncontract L1BeaconRootsSender {\n    /// @notice The OP L1CrossDomainMessenger contract\n    IL1CrossDomainMessenger public immutable L1_MESSENGER;\n\n    /// @notice The L2BeaconRoots contract on the L2\n    L2BeaconRoots public immutable L2_BEACON_ROOTS;\n\n    /// @notice The required gas limit for executing the set function on the L2BeaconRoots contract\n    uint32 public constant L2_BEACON_ROOTS_SET_GAS_LIMIT = 27_000;\n\n    /// @notice Event emitted when a block root is sent to the L2\n    /// @notice The event can be emitted multiple times for the same block root\n    /// @notice The event can be emitted for block roots in the past\n    /// @notice The protocol does not guarantee that the event is emitted for every block root\n    /// @param timestamp: The timestamp of the beacon chain block\n    /// @param blockRoot: The beacon chain block root at the given timestamp\n    event BlockRootSent(uint256 timestamp, bytes32 blockRoot);\n\n    /// @notice Timestamp out of range for the the beacon roots buffer ring.\n    error TimestampOutOfRing();\n\n    /// @notice Timestamp is in the future\n    error TimestampInTheFuture();\n\n    /// @notice Beacont root is missing for the given timestamp.\n    error BeaconRootMissing();\n\n    /// @notice The L1 official Beacon Roots contracts storing the beacon chain block roots\n    /// @dev https://eips.ethereum.org/EIPS/eip-4788\n    address internal constant L1_BEACON_ROOTS = 0x000F3df6D732807Ef1319fB7B8bB8522d0Beac02;\n\n    /// @notice The length of the beacon roots ring buffer.\n    /// @dev https://eips.ethereum.org/EIPS/eip-4788\n    uint256 internal constant BEACON_ROOTS_HISTORY_BUFFER_LENGTH = 8191;\n\n    /// @notice The number of seconds per slot in the beacon chain (12 seconds)\n    uint256 internal constant BEACON_SECONDS_PER_SLOT = 12;\n\n    constructor(address _messenger, address _l2BeaconRoots) {\n        L1_MESSENGER = IL1CrossDomainMessenger(_messenger);\n        L2_BEACON_ROOTS = L2BeaconRoots(_l2BeaconRoots);\n    }\n\n    /// @notice Sends a beacon block root to the L2\n    /// @notice Retrieves the block root from the official beacon roots contract and sends it to the L2\n    /// @param _timestamp: The timestamp of the beacon chain block\n    function sendBlockRoot(uint256 _timestamp) public {\n        uint256 currentBlockTimestamp = block.timestamp;\n\n        // If the _timestamp is not guaranteed to be within the beacon block root ring buffer, revert.\n        if (_timestamp > currentBlockTimestamp) {\n            revert TimestampInTheFuture();\n        }\n\n        if ((currentBlockTimestamp - _timestamp) >= (BEACON_ROOTS_HISTORY_BUFFER_LENGTH * BEACON_SECONDS_PER_SLOT)) {\n            revert TimestampOutOfRing();\n        }\n\n        bytes32 beaconRoot = _getBlockRoot(_timestamp);\n        if (beaconRoot == bytes32(0)) {\n            revert BeaconRootMissing();\n        }\n\n        _send(_timestamp, beaconRoot);\n    }\n\n    /// @notice Sends beacon block root of the current block to the L2\n    /// @notice Retrieves the block root from the official beacon roots contract and sends it to the L2\n    /// @notice The beacon block root is for the parent beacon chain slot of the current block\n    function sendCurrentBlockRoot() public {\n        uint256 currentBlockTimestamp = block.timestamp;\n\n        bytes32 beaconRoot = _getBlockRoot(currentBlockTimestamp);\n        if (beaconRoot == bytes32(0)) {\n            revert BeaconRootMissing();\n        }\n\n        _send(currentBlockTimestamp, beaconRoot);\n    }\n\n    /// @notice Retrieves a beacon block root from the official beacon roots contract (EIP-4788)\n    /// @param _timestamp: The timestamp of the beacon chain block\n    function _getBlockRoot(uint256 _timestamp) internal view returns (bytes32 blockRoot) {\n        (bool success, bytes memory result) = L1_BEACON_ROOTS.staticcall(abi.encode(_timestamp));\n        if (success && result.length > 0) {\n            return abi.decode(result, (bytes32));\n        } else {\n            return bytes32(0);\n        }\n    }\n\n    /// @notice Sends a beacon block root to the L2\n    /// @param _timestamp: The timestamp of the beacon chain block\n    /// @param _beaconRoot: The beacon chain block root at the given timestamp\n    function _send(uint256 _timestamp, bytes32 _beaconRoot) internal {\n        // Send the block root to the L2\n        L1_MESSENGER.sendMessage(\n            address(L2_BEACON_ROOTS),\n            abi.encodeCall(L2_BEACON_ROOTS.set, (_timestamp, _beaconRoot)),\n            L2_BEACON_ROOTS_SET_GAS_LIMIT\n        );\n\n        // Emit BlockRootSent event\n        emit BlockRootSent(_timestamp, _beaconRoot);\n    }\n}\n"
    },
    "contracts/src/L2BeaconRoots.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./L1BeaconRootsSender.sol\";\n\n/// @title IL2CrossDomainMessenger\n/// @notice Interface for the OP L2CrossDomainMessenger contract\ninterface IL2CrossDomainMessenger {\n    function xDomainMessageSender() external view returns (address);\n}\n\n/// @title L2BeaconRoots\n/// @notice The L2BeaconRoots contract stores the beacon chain block roots on the L2\ncontract L2BeaconRoots {\n    /// @notice The L1CrossDomainMessenger contract\n    IL2CrossDomainMessenger public immutable MESSENGER;\n\n    /// @notice The L1BeaconRootsSender contract on the L1\n    address public L1_BEACON_ROOTS_SENDER;\n\n    /// @notice The beacon chain block roots stored by timestamps\n    mapping(uint256 => bytes32) public beaconRoots;\n\n    /// @notice Event emitted when the smart contract is initialized\n    /// @param _l1BeaconRootsSender: The address of the L1BeaconRootsSender contract on L1\n    event Initialized(address _l1BeaconRootsSender);\n\n    /// @notice Event emitted when a beacon block root is set\n    /// @notice The event can be emitted multiple times for the same block root\n    /// @notice The event can be emitted for block roots in the past\n    /// @notice The protocol does not guarantee that the event is emitted for every block root\n    /// @param timestamp: The timestamp of the beacon chain block\n    /// @param blockRoot: The beacon chain block root at the given timestamp\n    event BeaconRootSet(uint256 timestamp, bytes32 blockRoot);\n\n    /// @param _messenger: The address of the L2 CrossDomainMessenger contract\n    constructor(address _messenger) {\n        MESSENGER = IL2CrossDomainMessenger(_messenger);\n    }\n\n    /// @notice Initialize the contract with the L1BeaconRootsSender address.\n    /// @param _l1BeaconRootsSender: The address of the L1BeaconRootsSender contract\n    /// @dev The flow is:\n    ///       1) Deploy L2BeaconRoots on L2\n    ///       2) Deploy L1BeaconRootsSender on L1 (passing the address of the deployed L2BeaconRoots to the constructor)\n    ///       3) Initialize L2BeaconRoots with the L1BeaconRootsSender address\n    function init(address _l1BeaconRootsSender) public {\n        require(address(L1_BEACON_ROOTS_SENDER) == address(0), \"BeaconRoots: Contract has already been initialized\");\n        L1_BEACON_ROOTS_SENDER = _l1BeaconRootsSender;\n        emit Initialized(_l1BeaconRootsSender);\n    }\n\n    /// @notice Sets the beacon root for a given beacon chain timestamp\n    /// @notice This function must be called by the L1BeaconRootsSender contract on L1 through the OP CrossDomainMessenger\n    /// @param _beaconTimestamp: The timestamp of the beacon chain block\n    /// @param _beaconRoot: The beacon chain block root at the given timestamp\n    function set(uint256 _beaconTimestamp, bytes32 _beaconRoot) public {\n        require(msg.sender == address(MESSENGER), \"BeaconRoots: Direct sender must be the CrossDomainMessenger\");\n\n        require(\n            MESSENGER.xDomainMessageSender() == L1_BEACON_ROOTS_SENDER,\n            \"BeaconRoots: Remote sender must be the Beacon Roots Sender contract\"\n        );\n\n        beaconRoots[_beaconTimestamp] = _beaconRoot;\n\n        emit BeaconRootSet(_beaconTimestamp, _beaconRoot);\n    }\n\n    /// @notice Gets the beacon root for a given beacon chain timestamp\n    /// @param _beacon_timestamp: The timestamp of the beacon chain block\n    function get(uint256 _beacon_timestamp) public view returns (bytes32) {\n        return beaconRoots[_beacon_timestamp];\n    }\n}\n"
    },
    "contracts/src/L2BeaconRootVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n// See https://github.com/nerolation/slashing-proofoor/blob/main/src/SlashingProofoor.sol\n"
    }
  },
  "settings": {
    "viaIR": true,
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}